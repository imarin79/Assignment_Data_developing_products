#############################################
# The Abimael Laboratory of Neurometabolism #
#############################################

#APP for General Data Analysis and Plotting from a csv or excel file:

#install.packages(shiny)
#install.packages(tidyr)
#install.packages(dplyr)
#install.packages(stringr)
#install.packages(ggplot2)
#install.packages(ggpmisc)
#install.packages(shinyFeedback)
#install.packages(ggtext)
#install.packages(kableExtra)
#install.packages(data.table)
#install.packages(RCurl)
#install.packages("assertthat")
# install.packages("reactable")

#List of shiny apps for statistics: http://asas.yingjiehu.com 

library(shiny)
library(tidyr)
library(dplyr)
library(tidyverse)
library(stringr)
library(ggplot2)
library(ggpmisc)
library(shinyFeedback)
library(ggtext)
library(shinyFiles)
library(fs)
library(stringi)
library(DT)
library(jsonlite)
library(shinyjs)
library(tools)
library(shinysense)
library(readxl)
library(assertthat)
library(plotrix)
library(plyr)
library(ggpubr)
library(rlang)
library(shinydashboard)
library(hablar)
library(shinythemes)
library(plotly)
library(gridExtra)
library(cowplot)
library(broom)
library(purrr)
library(reactable)
library(Hmisc)
library(stats)
library(magrittr)
library(gtable)

#Here is the user interfase:
ui <- fluidPage(
    useShinyjs(),
    tags$head(
        tags$style(HTML("hr {border-top: 1px solid #000000;}"))
    ),
    fluidRow(
        column(12,
               hr(),
               h3("Plotting from table file",style = "color:blue")
        )
    ),
    sidebarLayout(
        sidebarPanel(width = 4,
                     sidebarMenu(
                         #Here we determine the font size and style of the sidebar.
                         tags$head(
                             tags$link(rel = "stylesheet", type = "text/css", href = "shiny.css"),
                             tags$style("label {font-family: 'Helvetica'; font-size:16px; font-weight:bold;text-align: center;}"), #.selectize-input {font-size: 16px; height: 20px; padding-top: 5px, #form-group {margin-bottom:0 !important; #text text-align: center}"),
                             # tags$style(HTML(".form-group {margin-bottom: 5px !important;}")) #this make the boxes in sidebar close together.
                             tags$style(HTML('.form-group {width: 300px; font-size: 0px; text-align:left;}')) #the font-size controls the space between the titles and the bar
                             
                         ),
                         br(),
                         br(),
                         h4("Upload a excel template with your data in it:"),
                         fileInput(inputId = "file1", label="", 
                                   multiple=FALSE,
                                   accept=c(".csv",".xlsx",".xls"),
                                   width = "70%"),
                         h4("Number of groups (control, mutant, etc.):"), #, align="left",style = "font-family:'Helvetica';font-size: 1px; font-weight:bold;"
                         div(selectizeInput(inputId = "groups",
                                            label =  "",   #shiny::HTML("<p>(control, mutant, etc.)</p>")  #Here we separate the text in two different lines
                                            choices = c(2:100),
                                            multiple = FALSE,
                                            width = "40%")),
                         div(textOutput(outputId = "names_groups_input")),
                         br(),
                         h4("Subgroups in each group (cortex, cereb, etc.):"), #, align="left",style = "font-family:'Helvetica';font-size: 20px; font-weight:bold;"
                         selectizeInput(inputId = "subgroups", 
                                        label = "", # shiny::HTML("<p>(cortex, hippocampus, etc.) </p>"), 
                                        choices = c(1:100),
                                        multiple = FALSE,
                                        width = "40%"),
                         br(),
                         checkboxGroupInput(   #We will make a reactive function in the server to select the type of plot we will make 
                             inputId = "plot_type",
                             label = "",
                             choices = list("Bar_plot"),          #This is new. We put here a list. 
                             selected = "Bar_plot"),
                       
                         fluidRow(
                             br(),
                             br(),
                             br(),
                             
                         )
                         # , This is the "Run" button where the output will be updated based on the information we have included in the sidebarlayout. 
                         # fluidRow(
                         #   actionButton(inputId = "update",
                         #                label = "Run",
                         #                style="float:right ; background-color: #24a0ed; color: white;",
                         #                class = "btn-lg")
                         # ),
                     )
        ),
        mainPanel(width = 8,
                  tabsetPanel(
                      tabPanel(title = "Uploaded_Table", 
                               DTOutput("Uploaded_Table")),
                      tabPanel(title = "Plots", 
                               fluidRow(
                                   uiOutput("plot_list")
                               ),
                               downloadButton(outputId = "downloadPlot", "Download Plots (pdf file)"))
                      )
                  )
        )
    )


server <- function(input, output, session){
    
    #Here we create this object to indicate the number of groups and subgroups:
    group_names <- reactive({
        as.integer(input$groups)
    })
    
    #Here we create this object to indicate the number of subgroups.
    subgroup_names <- reactive({
        as.integer(input$subgroups)
    })
    
    #Here we generate a reactive object, data_input, that is able to upload a csv, xlsx, or xls file.
    data_input <- reactive({ 
        req(input$file1) 
        
        if(see_if(has_extension(input$file1$datapath, "csv")) == TRUE){
            df <- read.csv(input$file1$datapath, header = input$header,sep = input$sep)
        }else if(see_if(has_extension(input$file1$datapath, "xlsx")) == TRUE){
            df <- read_excel(input$file1$datapath)
        }else if(see_if(has_extension(input$file1$datapath, "xls")) == TRUE){
            df <- read_excel(input$file1$datapath)
        }
        return(df)
    })
    
    #For data wrangling, dplyr or tidyverse works better than just regular R data wrangling.
    newdata_input5 <- reactive({
        newdata_input <-  rep(colnames(data_input()[1:subgroup_names()]),each=subgroup_names()) #Here we want to repeat each element x number of times consecutively.
        newdata_input2 <- as.vector(unlist(data_input()[1:subgroup_names()])) #Here we create a vector from three consecutive columns of the dataframe.
        newdata_input3 <- as.data.frame(cbind(newdata_input, newdata_input2))
        newdata_input2 <- as.vector(unlist(data_input()[(subgroup_names()+1):(subgroup_names() * group_names())]))
        newdata_input5 <- as.data.frame(cbind(newdata_input, newdata_input2))
        newdata_input5 <- rbind(newdata_input3, newdata_input5)
        newdata_input5  <- newdata_input5%>%
            add_column(groups = c(rep("group1",nrow(newdata_input5)/2), rep("group2",nrow(newdata_input5)/2)))%>%
            dplyr::rename(subgroups = newdata_input, values = newdata_input2, groups = groups) %>%
            hablar::convert(num(values))
        
    })
    
    data_input2 <- reactive({
        newdata_input6  <- newdata_input5()%>%
            group_by(groups, subgroups)%>%
            dplyr::summarise(across(where(is.numeric), list(mean=mean, se = std.error)),.groups = 'drop')%>%
            dplyr::rename(values = values_mean, se = values_se)
    })
    
    output$Uploaded_Table <- renderDT({
        data_input()
    })
    
    output$Bar_plot <- renderPlot({   
        if(("Bar_plot" %in% input$plot_type) & (subgroup_names() == ncol(data_input())/2)){
            p1 <- ggplot(data_input2(),aes(x=subgroups, y=values, fill= groups, group = groups))+
                geom_errorbar(aes(x=subgroups, ymin=values-se, ymax=values+se, color=groups),width=0.2, position=position_dodge(0.8))+
                geom_bar(stat="identity", width = 0.7, position = position_dodge(0.8))+
                geom_point(data=newdata_input5(), aes(y=values,group=groups), stat="identity",
                           position_jitterdodge(jitter.width = 0.18,dodge.width=0.8),
                           alpha=0.5,
                           size=6,
                           shape = 21)+
                theme_classic()+
                stat_compare_means(data = newdata_input5(), 
                                   paired=F,
                                   method.args = list(var.equal = TRUE, alternative=c("two.sided")),
                                   # conf.level = 0.95,
                                   label = "p.signif", 
                                   size=10, 
                                   method="t.test", 
                                   label.y = max(data_input2()["values"])*1.2)+ #here we compare subgroups, asterics are demarcated by "p.signif"
                scale_color_manual(values=c("dodgerblue1", "red"), name= "Animal")+ #To color errorbars
                scale_fill_manual(values=c("dodgerblue1", "red"), name= "Animal")+ #To color bars
                scale_y_continuous(name = "Values", expand=c(0,0), breaks=seq(0,2,0.5))+
                scale_x_discrete(name = "")+
                theme(legend.title = element_blank())+
                theme(axis.title.y = element_text(color = "black"),
                      axis.title.y.right = element_text(color = "blue"))+
                theme(axis.text=element_text(size=12, color = "black",family="Helvetica"), #Helvetica because ggsave has a hard time saving it in Arial.
                      axis.title=element_text(size=12,face="bold", color = "black"))+
                theme(axis.text.x = element_text(angle = 360, hjust = 0.5, vjust = 1.2,color = "black"))+
                theme(axis.line = element_line(size = 0.3, color = "black"),axis.ticks =  element_line(colour = "black", size = 0.3))+                                                            
                theme(axis.ticks.length = unit(0.5, "cm"))+
                theme(plot.margin=unit(c(1.5,1.5,1.5,1.5),"cm"))+
                coord_cartesian(ylim= c(0,max(data_input2()["values"])*1.5))
            
            print(p1)
            
        }
    })
    
    output$plot_list <- renderUI({
        plot_output_list <- lapply(input$plot_type, 
                                   function(plotname) {
                                       column(width=5, plotOutput(plotname)) ##wrap the plotOutput in column to render side-by-side
                                   })
        
        do.call(tagList, plot_output_list)
    })
    
   
    #To download the table, we have to make a reactive object, in this case vals, and assign to it the dataframe we created, in this case statistical_test. Otherwise, it will not work because reactable() generates a 
    # html file which is not compatible with pdf or csv files. 
    
   
#This is to download a pdf file with all plots selected:
    output$downloadPlot <- downloadHandler(
        filename = function() {
            "Rplots.pdf"
        },
        
        content = function(file) {
            pdf(file)
            
            
            p1 <- ggplot(data_input2(),aes(x=subgroups, y=values, fill= groups, group = groups))+
                geom_errorbar(aes(x=subgroups, ymin=values-se, ymax=values+se, color=groups),width=0.2, position=position_dodge(0.8))+
                geom_bar(stat="identity", width = 0.7, position = position_dodge(0.8))+
                geom_point(data=newdata_input5(), aes(y=values,group=groups), stat="identity",
                           position_jitterdodge(jitter.width = 0.18,dodge.width=0.8),
                           alpha=0.5,
                           size=4,
                           shape = 21)+
                theme_classic()+
                stat_compare_means(data = newdata_input5(), 
                                   paired=F,
                                   method.args = list(var.equal = TRUE, alternative=c("two.sided")),
                                   # conf.level = 0.95,
                                   label = "p.signif", 
                                   method="t.test", 
                                   size=7, 
                                   label.y = max(data_input2()["values"])*1.35)+ #here we compare subgroups, asterics are demarcated by "p.signif"
                scale_color_manual(values=c("dodgerblue1", "red"), name= "Animal")+ #To color errorbars
                scale_fill_manual(values=c("dodgerblue1", "red"), name= "Animal")+ #To color bars
                scale_y_continuous(name = "Values", expand=c(0,0), breaks=seq(0,2,0.5))+
                scale_x_discrete(name = "")+
                theme(legend.title = element_blank())+
                theme(axis.title.y = element_text(color = "black"),
                      axis.title.y.right = element_text(color = "blue"))+
                theme(axis.text=element_text(size=10, color = "black",family="Helvetica"), #Helvetica because ggsave has a hard time saving it in Arial.
                      axis.title=element_text(size=10,face="bold", color = "black"))+
                theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1,color = "black"))+
                theme(axis.line = element_line(size = 0.3, color = "black"),axis.ticks =  element_line(colour = "black", size = 0.3))+
                # theme(axis.ticks.length = unit(0.3, "cm"))+
                theme(plot.margin=unit(c(0.5,0.1,0.5,0.1),"cm"))+  #top, right, bottom, left
                coord_cartesian(ylim= c(0,max(data_input2()["values"])*1.5))
            
                grid.arrange(arrangeGrob(p1), ncol=1, nrow = 1)
           
            
            dev.off()
        }
        
    )
}


# Run the application 
shinyApp(ui = ui, server = server)

